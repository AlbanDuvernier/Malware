#include "stdafx.h"
#include <stdlib.h>
#include "stdio.h"
#include "string.h"
#include "math.h"
#include <Windows.h>
#include <Wincrypt.h>
#include <winternl.h>


int checker(char input[],char check[]);

/*
__declspec(noinline) int checker(char input[], char check[])
{

    int i,result=1;
    for(i=0; input[i]!='\0' || check[i]!='\0'; i++) {
        if(input[i] != check[i]) {
            result=0;
            break;
        }
    }
    return result;
}
*/

static char szHash[33];

void printHash(BYTE* pHash, DWORD dwHashLen)
{
  
  memset(szHash, 0, 33);
  for (DWORD i = 0; i < dwHashLen; i++)
  {
    sprintf(szHash + (i * 2), "%02x", pHash[i]);
  }
}


//déclaration du type des fonctions de type printf
typedef int (*type_printf) (const char *, ...);
typedef int (*type_scanf) (const char *, ...);
typedef int (*type_checker) (const char * , ...);

char debut_printf[] = {'\x6a', '\x0c', '\x68', '\x60', '\x57', '\xb0', '\x78', '\xe8', '\xc0', '\xb5', '\xfa', '\xff'};

int _tmain(int argc, _TCHAR* argv[])
{

	type_printf __;
		
	char *p = (char *) scanf;
	int found = 0;
	while( !found) {
		if (memcmp(p, & debut_printf, 12) == 0) {
			found = 1;
		}
		else { p-- ; }
	}

	__ = (type_printf) p;


	
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	BYTE* pHashData = 0;
	DWORD dwDataLen = 0;
	char szData[40];
	int i=0;
	__("Entrez un message de moins de 64 lettres et ecrit en hexa.\n");
	scanf("%s",szData);
	DWORD dwHashLen = 0;
	if (strlen(szData)<64){
		if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
		{
			__("CryptAcquireContext a échoué.\n");
			return 1;
		}

		if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
		{
			__("CryptCreateHash a échoué.\n");
			return 1;
		}

		dwDataLen = strlen(szData) + 1;
		if (!CryptHashData(hHash, (BYTE*)szData, dwDataLen, 0))
		{
			__("CryptHashData a échoué.\n");
			return 1;
		}

		if (!CryptGetHashParam(hHash, HP_HASHVAL, NULL, &dwHashLen, 0))
		{
			__("CryptGetHashParam a échoué.\n");
			return 1;
		}

		pHashData = (BYTE*)malloc(dwHashLen);
		if (!CryptGetHashParam(hHash, HP_HASHVAL, pHashData, &dwHashLen, 0))
		{
			__("CryptGetHashParam a échoué.\n");
			return 1;
		}
	}
	

	__("Le mot entré est : %s\n",szData);
	printHash(pHashData, dwHashLen);
	
	__("Son hash en MD5 vaut: %s\n", szHash);

	PEB *ppeb;
	_asm{
		mov eax, fs:[0x30]
		mov ppeb, eax
	}
	p = (char *) ppeb;

	if (ppeb->BeingDebugged ==1 || p[104] & 0x70)
	{

	}
	else 
	{
		
		char hex[] ={'\x55'^42, '\x8B'^42, '\xEC'^42, '\x8B'^42, '\x4D'^42, '\x0C'^42, '\x56'^42, '\x8B'^42, '\x75'^42, '\x08'^42, '\xB8'^42, '\x01'^42, '\x00'^42, '\x00'^42, '\x00'^42, '\x2B'^42,
					'\xF1'^42, '\x8A'^42, '\x14'^42, '\x0E'^42, '\x84'^42, '\xD2'^42, '\x75'^42, '\x04'^42, '\x38'^42, '\x11'^42, '\x74'^42, '\x09'^42, '\x3A'^42, '\x11'^42, '\x75'^42, '\x03'^42,
					'\x41'^42, '\xEB'^42, '\xEE'^42, '\x33'^42, '\xC0'^42, '\x5E'^42, '\x5D'^42, '\xC3'^42};

		type_checker ___;
		___ = (type_checker) (&hex);
		char input[] ="a618df803d5516a578d3407e7556241e"; 
		for(int i = 0; i<40; i++) hex[i]^=42; 
		while (!___(input,szHash))
		{
			CryptDestroyHash(hHash);
			CryptReleaseContext(hProv, 0);
			free(pHashData);
			__("\nEntrez un message de moins de 64 lettres et ecrit en hexa.\n");
			scanf("%s",szData);
			if (strlen(szData)<64)
			{
				if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
				{
					printf("CryptAcquireContext a échoué.\n");
					return 1;
				}

				if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
				{
					printf("CryptCreateHash a échoué.\n");
					return 1;
				}

				dwDataLen = strlen(szData) + 1;
				if (!CryptHashData(hHash, (BYTE*)szData, dwDataLen, 0))
				{
					printf("CryptHashData a échoué.\n");
					return 1;
				}

				if (!CryptGetHashParam(hHash, HP_HASHVAL, NULL, &dwHashLen, 0))
				{
					printf("CryptGetHashParam a échoué.\n");
					return 1;
				}

				pHashData = (BYTE*)malloc(dwHashLen);
				if (!CryptGetHashParam(hHash, HP_HASHVAL, pHashData, &dwHashLen, 0))
				{
					printf("CryptGetHashParam a échoué.\n");
					return 1;
				}
				printHash(pHashData, dwHashLen);
				__("Son hash en MD5 vaut: %s\n",szHash );

			}
				  
		}
		for(int i = 0; i<40; i++) hex[i]^=42; 
		printf("Bravo!!! Tu as trouvé le mot caché!!!"); 
	}
	  


	while(1);
    return 0;
}